{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Adjunct","text":"<p>Adjunct is a collection of miscellaneous modules.</p> <p>It's intended that this will eventually end up as a namespace package.</p>"},{"location":"#development-and-testing","title":"Development and Testing","text":"<p>You should make sure you've just installed, as it's used for running maintenance tasks.</p> <p>You're expected to make sure you've uv installed as it's used for managing the project. Also, for linting and code fixes, make sure you've ruff installed too. If you've uv installed already, install ruff with:</p> <pre><code>uv tool install ruff\n</code></pre> <p>For normal development, you can run the test suite with:</p> <pre><code>just tests\n</code></pre> <p>If you want to run the test suite across all supported Python runtimes, you'll need tox. Like with ruff, you can install it with uv. You'll need to make sure that you have the tox-uv plugin installed too:</p> <pre><code>uv tool install tox --with tox-uv\n</code></pre>"},{"location":"adjunct.compat/","title":"adjunct.compat","text":""},{"location":"adjunct.compat/#adjunct.compat.parse_header","title":"<code>parse_header(line)</code>","text":"<p>Parse HTTP headers with the same format as <code>Content-Type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>a HTTP header line</p> required <p>Returns:</p> Type Description <code>tuple[str, dict[str, str]]</code> <p>The main value and a dictionary of options.</p> <p>(Copied from Python's <code>cgi</code> module until I can find a better alternative.)</p>"},{"location":"adjunct.dbhelpers/","title":"adjunct.dbhelpers","text":"<p>Helpers for interacting with databases.</p>"},{"location":"adjunct.dbhelpers/#adjunct.dbhelpers.execute","title":"<code>execute(con, sql, args=())</code>","text":"<p>Execute an SQL statement.</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>_Connection</code> <p>connection object</p> required <code>sql</code> <code>str</code> <p>the statement to execute</p> required <code>args</code> <code>Sequence[Scalar]</code> <p>arguments to interpolate into the statement</p> <code>()</code> <p>Returns:</p> Type Description <code>int | None</code> <p>The value of <code>lastrowid</code>, usually an autogenerated primary key.</p>"},{"location":"adjunct.dbhelpers/#adjunct.dbhelpers.query","title":"<code>query(con, sql, args=())</code>","text":"<p>Run an SQL query.</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>_Connection</code> <p>connection object</p> required <code>sql</code> <code>str</code> <p>the statement to execute</p> required <code>args</code> <code>Sequence[Scalar]</code> <p>arguments to interpolate into the statement</p> <code>()</code> <p>Yields:</p> Type Description <code>Row</code> <p>The rows of the result.</p>"},{"location":"adjunct.dbhelpers/#adjunct.dbhelpers.query_row","title":"<code>query_row(con, sql, args=(), *, default=None)</code>","text":"<p>Run an SQL query expected to return a single row.</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>_Connection</code> <p>connection object</p> required <code>sql</code> <code>str</code> <p>the statement to execute</p> required <code>args</code> <code>Sequence[Scalar]</code> <p>arguments to interpolate into the statement</p> <code>()</code> <code>default</code> <code>Row | None</code> <p>value to return if no rows are returned by the query</p> <code>None</code> <p>Returns:</p> Type Description <code>Row | None</code> <p>The matched row.</p>"},{"location":"adjunct.dbhelpers/#adjunct.dbhelpers.query_value","title":"<code>query_value(con, sql, args=(), *, default=None)</code>","text":"<p>Run an SQL query expected to return a single value.</p> <p>Parameters:</p> Name Type Description Default <code>con</code> <code>_Connection</code> <p>connection object</p> required <code>sql</code> <code>str</code> <p>the statement to execute</p> required <code>args</code> <code>Sequence[Scalar]</code> <p>arguments to interpolate into the statement</p> <code>()</code> <code>default</code> <code>Scalar</code> <p>value to return if no rows are returned by the query</p> <code>None</code> <p>Returns:</p> Type Description <code>Scalar</code> <p>The first field of the matched row.</p>"},{"location":"adjunct.discoverfeeds/","title":"adjunct.discoverfeeds","text":"<p>Feed discovery.</p>"},{"location":"adjunct.discoverfeeds/#adjunct.discoverfeeds.discover_feeds","title":"<code>discover_feeds(url)</code>","text":"<p>Discover any feeds at the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of page to extract feeds from.</p> required <p>Returns:</p> Type Description <code>Collection[dict[str, str]]</code> <p>The feeds in order of priority. Atom feeds are prioritised first, followed by RDF, and then finally RSS feeds.</p>"},{"location":"adjunct.discovery/","title":"adjunct.discovery","text":"<p>Discovery via HTML  elements.</p> <p>For most purposes, adjunct.discovery.fetch_meta should do anything you need.</p>"},{"location":"adjunct.discovery/#adjunct.discovery.Extractor","title":"<code>Extractor</code>","text":"<p>               Bases: <code>HTMLParser</code></p> <p>A simple subclass of html.parser.HTMLParser for extracting metadata like from <code>&lt;meta&gt;</code> and <code>&lt;link&gt;</code> tags from the header of a HTML document.</p> <p>It's recommended you use the adjunct.discovery.Extractor.extract class method rather than instantiating this class directly.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>str</code> <p>the base URL for the document</p> required <p>Attributes:</p> Name Type Description <code>base</code> <code>str</code> <p>the base URL for the document; the <code>&lt;base&gt;</code> tag is used if found</p> <code>collected</code> <code>list[dict[str, str]]</code> <p>any collected links; each entry is a dictionary of the attributes</p> <code>properties</code> <code>list[tuple[str, str]]</code> <p>any collected <code>&lt;meta&gt;</code> tags with <code>property</code> and <code>content</code> attributes</p>"},{"location":"adjunct.discovery/#adjunct.discovery.Extractor.extract","title":"<code>extract(fh, base='.', encoding='UTF-8')</code>  <code>classmethod</code>","text":"<p>Extract the link tags from header of a HTML document to be read.</p> <p>Parameters:</p> Name Type Description Default <code>fh</code> <code>IOBase</code> <p>a file-like object to read the HTML document from.</p> required <code>base</code> <code>str</code> <p>A base path/URL to use of URLs in the document. Note that the <code>&lt;base&gt;</code> tag will take priority.</p> <code>'.'</code> <code>encoding</code> <code>str</code> <p>default text encoding to assume for the document.</p> <code>'UTF-8'</code> <p>Returns:</p> Type Description <code>Extractor</code> <p>The parser with all links extracted and canonicalised.</p>"},{"location":"adjunct.discovery/#adjunct.discovery.fetch_meta","title":"<code>fetch_meta(url, extractor=Extractor)</code>","text":"<p>Extract the  tags from the HTML document at the given URL.</p> <p>As this is fetching the document over HTTP, it can also support the Link header.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the document to extract the link tags from.</p> required <code>extractor</code> <code>type[Extractor]</code> <p>an Extractor subclass</p> <code>Extractor</code> <p>Returns:</p> Type Description <code>tuple[Collection[dict[str, str]], Collection[tuple[str, str]]]</code> <p>The link tag data and any properties discovered in meta tags.</p>"},{"location":"adjunct.discovery/#adjunct.discovery.fix_attributes","title":"<code>fix_attributes(attrs)</code>","text":"<p>Normalise and clean up the attributes, and put them in a dict.</p> <p>Attribute names are normalised to lowercase; whitespace within values is trimmed; if the value of an attribute is <code>None</code>, it's replaced with an empty string; and the values of the <code>rel</code> and <code>type</code> attributes are converted to lowercase.</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>list[tuple[str, str | None]]</code> <p>raw attributes</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>cleaned-up attributes</p>"},{"location":"adjunct.fixtureutils/","title":"adjunct.fixtureutils","text":"<p>Test utilities for creating WSGI fixtures for testing HTTP clients.</p>"},{"location":"adjunct.fixtureutils/#adjunct.fixtureutils.basic_response","title":"<code>basic_response(start_response, code, body='')</code>","text":"<p>Send a plaintext document.</p> <p>Parameters:</p> Name Type Description Default <code>start_response</code> <code>_start_response</code> <p>a callable implementing the WSGI <code>start_response</code> interface</p> required <code>code</code> <code>int</code> <p>the HTTP status code to use</p> required <code>body</code> <code>str</code> <p>the body of the response</p> <code>''</code>"},{"location":"adjunct.fixtureutils/#adjunct.fixtureutils.extract_environment","title":"<code>extract_environment(environ)</code>","text":"<p>Extract any CGI environment variable from a dictionary.</p>"},{"location":"adjunct.fixtureutils/#adjunct.fixtureutils.fixture","title":"<code>fixture(app, *, returns_app=False, timeout=5)</code>","text":"<p>Spin up a fixture application up in its own process.</p> <p>Set <code>returns_app</code> if <code>app</code> is a callable that returns the actual app (such as a class).</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>_app</code> <p>a WSGI app or a callable that returns a WSGI app</p> required <code>returns_app</code> <code>bool</code> <p>treat <code>app</code> as a callable that returns a WSGI app</p> <code>False</code> <code>timeout</code> <code>int</code> <p>maximum length of time to wait for the app to start</p> <code>5</code> <p>Yields:</p> Type Description <code>str</code> <p>The URL serving the WSGI application.</p>"},{"location":"adjunct.fixtureutils/#adjunct.fixtureutils.json_response","title":"<code>json_response(start_response, body)</code>","text":"<p>Send a JSON document with a \"200 OK\" status code.</p>"},{"location":"adjunct.fixtureutils/#adjunct.fixtureutils.make_fake_http_response","title":"<code>make_fake_http_response(code=200, body='', headers=None)</code>","text":"<p>Make a fake http.client.HTTPResponse object.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>HTTP status code</p> <code>200</code> <code>body</code> <code>str</code> <p>response body</p> <code>''</code> <code>headers</code> <code>list[tuple[str, str]] | None</code> <p>any headers to include, if any</p> <code>None</code> <p>Returns:</p> Type Description <code>HTTPResponse</code> <p>A fake response object.</p>"},{"location":"adjunct.fixtureutils/#adjunct.fixtureutils.read_body","title":"<code>read_body(environ)</code>","text":"<p>Read any input from the WSGI environment.</p>"},{"location":"adjunct.fixtureutils/#adjunct.fixtureutils.read_json","title":"<code>read_json(environ)</code>","text":"<p>Read a JSON document from the WSGI environment.</p>"},{"location":"adjunct.fixtureutils/#adjunct.fixtureutils.response","title":"<code>response(start_response, code, body=b'', headers=None)</code>","text":"<p>Construct a WSGI response.</p> <p>Parameters:</p> Name Type Description Default <code>start_response</code> <code>_start_response</code> <p>a callable implementing the WSGI <code>start_response</code> interface</p> required <code>code</code> <code>int</code> <p>the HTTP status code to use</p> required <code>body</code> <code>bytes</code> <p>the body of the response</p> <code>b''</code> <code>headers</code> <code>list[tuple[str, str]] | None</code> <p>any additional headers to send beside <code>Content-Type</code>.</p> <code>None</code> <p>Yields:</p> Type Description <code>Iterable[bytes]</code> <p>the wrapped body</p>"},{"location":"adjunct.gravatar/","title":"adjunct.gravatar","text":"<p>Gravatar support.</p> <p>For information on the parameters, see the SDK.</p>"},{"location":"adjunct.gravatar/#adjunct.gravatar.make_gravatar","title":"<code>make_gravatar(email, size=64, default='identicon', rating='pg')</code>","text":"<p>Generate a gravatar image URL.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>an email address</p> required <code>size</code> <code>int</code> <p>the size of the gravatar to generate</p> <code>64</code> <code>default</code> <code>str</code> <p>default image to generate</p> <code>'identicon'</code> <code>rating</code> <code>str</code> <p>the rating associated with the image</p> <code>'pg'</code> <p>Returns:</p> Type Description <code>str</code> <p>A Gravatar URL.</p>"},{"location":"adjunct.gravatar/#adjunct.gravatar.make_gravatar_img","title":"<code>make_gravatar_img(email, size=64, default='identicon', rating='pg')</code>","text":"<p>Generate a Gravatar <code>&lt;img&gt;</code> tag for the given email address.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>an email address</p> required <code>size</code> <code>int</code> <p>the size of the gravatar to generate</p> <code>64</code> <code>default</code> <code>str</code> <p>default image to generate</p> <code>'identicon'</code> <code>rating</code> <code>str</code> <p>the rating associated with the image</p> <code>'pg'</code> <p>Returns:</p> Type Description <code>str</code> <p>An <code>&lt;img&gt;</code> tag with suitable attributes.</p>"},{"location":"adjunct.html/","title":"adjunct.html","text":"<p>HTML parsing and serialisation support.</p>"},{"location":"adjunct.html/#adjunct.html.Element","title":"<code>Element</code>  <code>dataclass</code>","text":"<p>A HTML element.</p> <p>Attributes:</p> Name Type Description <code>tag</code> <code>str | None</code> <p>the tag name</p> <code>attrs</code> <code>dict</code> <p>the tag's attributes</p> <code>children</code> <code>list</code> <p>the child elements of the element</p>"},{"location":"adjunct.html/#adjunct.html.Element.serialize","title":"<code>serialize(dest=None)</code>","text":"<p>Serialise the element to a file-like object.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>TextIO | None</code> <p>the file-like object to serialise the document to; if this is <code>None</code>, as io.StringIO object will be created instead.</p> <code>None</code> <p>Returns:</p> Type Description <code>TextIO</code> <p>A file-like object containing the serialised element.</p>"},{"location":"adjunct.html/#adjunct.html.make","title":"<code>make(tag, attrs, *, close=None)</code>","text":"<p>Helper for quickly constructing a HTML tag.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>tag name</p> required <code>attrs</code> <code>Mapping[str, str | None]</code> <p>attributes to apply to the tag</p> required <code>close</code> <code>bool | None</code> <p>set to <code>True</code> or <code>False</code> to determine whether a closing tag should be generated; omit to let the function decide</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the tag</p>"},{"location":"adjunct.html/#adjunct.html.parse","title":"<code>parse(markup)</code>","text":"<p>Parse a HTML document, returning its root element.</p> <p>Parameters:</p> Name Type Description Default <code>markup</code> <code>str</code> <p>the document to parse</p> required <p>Returns:</p> Type Description <code>Element</code> <p>The root element of the document.</p>"},{"location":"adjunct.jsonutils/","title":"adjunct.jsonutils","text":""},{"location":"adjunct.jsonutils/#adjunct.jsonutils.load_json_documents","title":"<code>load_json_documents(payloads)</code>","text":"<p>Load multiple JSON documents from a string.</p> <p>Each JSON document is expected to be separated by whitespace or newlines.</p> <p>This is useful for processing streams of JSON objects, such as logs or data exports, where each line or block represents a separate entity.</p> <p>Parameters:</p> Name Type Description Default <code>payloads</code> <code>str</code> <p>A text stream containing JSON documents.</p> required <p>Yields:</p> Type Description <code>dict | list</code> <p>Parsed JSON objects/lists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; json_stream = '''\n... {\"name\": \"Alice\"}\n... {\"name\": \"Bob\"}\n... [1, 2, 3]\n... '''\n&gt;&gt;&gt; for doc in load_json_documents(json_stream):\n...     print(doc)\n{'name': 'Alice'}\n{'name': 'Bob'}\n[1, 2, 3]\n</code></pre>"},{"location":"adjunct.netstrings/","title":"adjunct.netstrings","text":"<p>Simple netstring reader implemented as a generator.</p>"},{"location":"adjunct.netstrings/#adjunct.netstrings.MalformedNetstringError","title":"<code>MalformedNetstringError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the netstring reader hits a parser error in the stream.</p>"},{"location":"adjunct.netstrings/#adjunct.netstrings.netstring_reader","title":"<code>netstring_reader(fd)</code>","text":"<p>Reads a sequence of netstrings from the given file object.</p> <p>Parameters:</p> Name Type Description Default <code>fd</code> <code>BufferedIOBase</code> <p>a file-like object to read from</p> required <p>Yields:</p> Type Description <code>Iterable[bytes]</code> <p>netstrings</p>"},{"location":"adjunct.netstrings/#adjunct.netstrings.parse","title":"<code>parse(ns)</code>","text":"<p>Parse a bytestring of netstrings.</p> <p>Parameters:</p> Name Type Description Default <code>ns</code> <code>bytes</code> <p>the netstrings to parse; there may be multiple in the input buffer</p> required <p>Returns:</p> Type Description <code>Sequence[bytes]</code> <p>All the netstrings found in the input buffer</p>"},{"location":"adjunct.oembed/","title":"adjunct.oembed","text":"<p>An oEmbed client library.</p> <p>As a general rule, you'll only ever need the adjunct.oembed.fetch function.</p>"},{"location":"adjunct.oembed/#adjunct.oembed.fetch","title":"<code>fetch(url, max_width=None, max_height=None)</code>","text":"<p>Fetch the oEmbed document for a resource at <code>url</code> from the provider.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of oEmbed document</p> required <code>max_width</code> <code>int | None</code> <p>desired maximum width of the thumbnail, if any</p> <code>None</code> <code>max_height</code> <code>int | None</code> <p>desired maximum height of the thumbnail, if any</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | int] | None</code> <p>An oEmbed document as a dictionary; <code>None</code> if the document could not be fetched or the content type of the response was not valid for an oEmbed document.</p>"},{"location":"adjunct.oembed/#adjunct.oembed.get_oembed","title":"<code>get_oembed(links, max_width=None, max_height=None)</code>","text":"<p>Given a URL, fetch its associated oEmbed information.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>Collection[dict[str, str]]</code> <p>a collection of link tags represented as attribute dictionaries</p> required <code>max_width</code> <code>int | None</code> <p>desired maximum width of the thumbnail, if any</p> <code>None</code> <code>max_height</code> <code>int | None</code> <p>desired maximum height of the thumbnail, if any</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str | int] | None</code> <p>An oEmbed document as a dictionary; <code>None</code> if the document could not be fetched or the content type of the response was not valid for an oEmbed document.</p>"},{"location":"adjunct.ogp/","title":"adjunct.ogp","text":"<p>An intensely pragmatic implementation of the Open Graph Protocol.</p> <p>This follows the specification rather than attempting to implement RDFa.</p>"},{"location":"adjunct.ogp/#adjunct.ogp--theory-of-operation","title":"Theory of Operation","text":"<p>The metadata consists of a list of properties. A property may be unstructured (a string) or structured (a list of properties). A property may appear more than once. Properties has the form \"ns:name\", while a metadata field to be attached to a property (thus making it structured) has the form \"ns:name:meta\".</p> <p>Metadata should be implemented as a multimap, but I'll be treating it as a map.</p> <p>Example of prefix with multiple entries:</p> <pre><code>&lt;body prefix=\"dc: http://purl.org/dc/terms/ schema: http://schema.org/\"&gt;\n</code></pre> <p>If this is present: <code>vocab=\"http://www.w3.org/2011/rdfa-context/rdfa-1.1\"</code>, an initial context is set up consisting of the namespaces given on that page.</p>"},{"location":"adjunct.ogp/#adjunct.ogp.find","title":"<code>find(props, type_, value=None)</code>","text":""},{"location":"adjunct.ogp/#adjunct.ogp.parse","title":"<code>parse(properties)</code>","text":""},{"location":"adjunct.ogp/#adjunct.ogp.to_meta","title":"<code>to_meta(props)</code>","text":""},{"location":"adjunct.opml/","title":"adjunct.opml","text":"<p>A simple, nay, simplistic! OPML parser.</p>"},{"location":"adjunct.opml/#adjunct.opml.OpmlError","title":"<code>OpmlError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when there's a problem parsing an OPML document.</p>"},{"location":"adjunct.opml/#adjunct.opml.Outline","title":"<code>Outline</code>","text":"<p>               Bases: <code>list</code></p> <p>An outline.</p> <p>Contains the element's attributes in the <code>attrs</code> member and the outlines nested within it as elements.</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>dict[str, str] | None</code> <p>any attributes on the element</p> <code>None</code> <code>items</code> <code>Sequence[Outline]</code> <p>any child outlines nested within this outline</p> <code>()</code> <code>root</code> <code>bool</code> <p>is this outline the root outline?</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>attrs</code> <code>dict[str, str]</code> <p>any attributes on the element</p> <code>root</code> <code>bool</code> <p>is this outline the root outline?</p>"},{"location":"adjunct.opml/#adjunct.opml.parse","title":"<code>parse(fh)</code>","text":"<p>Parses an OPML file from the given file object.</p> <p>Parameters:</p> Name Type Description Default <code>fh</code> <code>TextIO</code> <p>a file-like object containing an OPML document</p> required <p>Returns:</p> Type Description <code>Outline | None</code> <p>An outline if the document could be parsed, otherwise <code>None</code>.</p>"},{"location":"adjunct.opml/#adjunct.opml.parse_string","title":"<code>parse_string(s)</code>","text":"<p>Parses an OPML document from the given string.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>an OPML document.</p> required <p>Returns:</p> Type Description <code>Outline | None</code> <p>An outline if the document could be parsed, otherwise <code>None</code>.</p>"},{"location":"adjunct.opml/#adjunct.opml.parse_timestamp","title":"<code>parse_timestamp(ts)</code>","text":"<p>Convert an RFC 2822 timestamp (as used in OPML) to a UTC DateTime object.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>str</code> <p>an RFC 2822 timestamp</p> required <p>Returns:</p> Type Description <code>datetime | None</code> <p>A timezone-aware datetime, or <code>None</code> if the timestamp could not be parsed.</p>"},{"location":"adjunct.pagination/","title":"adjunct.pagination","text":"<p>Pagination support.</p>"},{"location":"adjunct.pagination/#adjunct.pagination.InvalidPageError","title":"<code>InvalidPageError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an invalid page is requested.</p>"},{"location":"adjunct.pagination/#adjunct.pagination.paginator","title":"<code>paginator(page_num, max_page, buffer_size=3)</code>","text":"<p>Pagination generator.</p> <p>Generates a sequence of page numbers, giving the pages at the beginning and end, and around the current page, with a number of buffer pages on each side of both. Omitted pages in the sequence are elided into a <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>page_num</code> <code>int</code> <p>the current page</p> required <code>max_page</code> <code>int</code> <p>the maximum page number to create a link to</p> required <code>buffer_size</code> <code>int</code> <p>the number of page links to generate on each side of the current page</p> <code>3</code> <p>Yields:</p> Type Description <code>int | None</code> <p>A page number, or <code>None</code> to indicate an elided series of pages.</p>"},{"location":"adjunct.passkit/","title":"adjunct.passkit","text":"<p>A partial replacement for passlib.</p> <p>Implementing an equivalent of its HtpasswdFile class and supporting functionality.</p> <p>It comes with a simple tool for manipulating JSONPasswd files.</p>"},{"location":"adjunct.passkit/#adjunct.passkit.JSONPasswdFile","title":"<code>JSONPasswdFile</code>","text":"<p>A class to manage user credentials stored in a JSON file.</p>"},{"location":"adjunct.passkit/#adjunct.passkit.JSONPasswdFile--file-format","title":"File Format","text":"<p>The JSON file should contain a dictionary where keys are usernames and values are structured data for checking password validity.</p> <p>The outer structure is as follows:</p> <pre><code>{\n  \"metadata\": {\n    \"type\": \"tag:talideon.com,2025:jsonpasswd\",\n    \"version\": 1\n  },\n  \"users\": {\n    \"&lt;username1&gt;\": { ... },\n    \"&lt;username2&gt;\": { ... }\n  }\n}\n</code></pre> <p>For the benefit of tools like file(1), the file should start with the metadata entry.</p> <p>Each value entry has the format:</p> <pre><code>{\n  \"alg\": \"scrypt\",\n  \"key\": \"&lt;hashed_password&gt;\",\n  \"salt\": \"&lt;salt_value&gt;\",\n  \"params\": {\n    \"n\": &lt;N_value&gt;,\n    \"r\": &lt;r_value&gt;,\n    \"p\": &lt;p_value&gt;\n  }\n}\n</code></pre> <p>Note that the salt and hashed password key are base64-encoded.</p> <p>Currently only the \"scrypt\" algorithm is supported.</p> Warning <p>it is the user's responsibility to lock the file if necessary to prevent concurrent access.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>the path to use when loading/saving the file</p> required <code>implementation</code> <code>str</code> <p>the method to use for encrypting the passwords; only \"scrypt\" is currently supported.</p> <code>'scrypt'</code> <p>Attributes:</p> Name Type Description <code>filepath</code> <code>str</code> <p>the path to use when loading/saving the file</p>"},{"location":"adjunct.passkit/#adjunct.passkit.JSONPasswdFile.check_password","title":"<code>check_password(username, password)</code>","text":"<p>Check is a user's password is valid.</p> <p>This verifies the provided password against the stored credentials for the given user.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the username whose password must be validated</p> required <code>password</code> <code>str</code> <p>the plaintext password to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the password is correct; <code>False</code> if the user doesn't exist or the password is invalid.</p> <p>Raises:</p> Type Description <code>UnknownAlgorithmError</code> <p>the password does not use a known algorithm</p>"},{"location":"adjunct.passkit/#adjunct.passkit.JSONPasswdFile.delete","title":"<code>delete(username)</code>","text":"<p>Remove the given user from the database.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the user to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the user was found and removed; <code>False</code> if the user was not found.</p>"},{"location":"adjunct.passkit/#adjunct.passkit.JSONPasswdFile.set_password","title":"<code>set_password(username, password)</code>","text":"<p>Set the given user's password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>the user's username</p> required <code>password</code> <code>str</code> <p>the new password</p> required Note <p>Calling this method will immediately save the file.</p>"},{"location":"adjunct.passkit/#adjunct.passkit.UnknownAlgorithmError","title":"<code>UnknownAlgorithmError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an entry has either an unknown algorithm or none.</p>"},{"location":"adjunct.singleton/","title":"adjunct.singleton","text":""},{"location":"adjunct.singleton/#adjunct.singleton.MutexError","title":"<code>MutexError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Failed to lock a file.</p>"},{"location":"adjunct.singleton/#adjunct.singleton.mutex","title":"<code>mutex(filename)</code>","text":"<p>Lock a mutex file.</p> <p>This can be used to prevent scripts from having more than one instance of themselves running at the same time as follows:</p> <pre><code>if __name__ == \"__main__\":\n    with mutex(__file__):\n        main()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path of the file to lock</p> required"},{"location":"adjunct.slog/","title":"adjunct.slog","text":"<p>Simple structured logging with spans.</p> <p>This module provides utilities for structured logging in JSON and Logfmt format, including the ability to create logging spans that carry contextual metadata.</p> <p>It builds on Python's built-in logging module.</p> <p>To configure logging to use structured logging, set up a logger with <code>JSONFormatter</code>:</p> <pre><code>import logging\n\nfrom adjunct.slog JSONFormatter, M, span\n\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nhandler = logging.StreamHandler()\nJSONFormatter.configure_handler(handler)\nlogger.addHandler(handler)\n</code></pre> <p>Both <code>M</code> and <code>span</code> can then be used to add structured metadata to log records:</p> <pre><code>logger.info(M(\"User logged in\", user=\"alice\"))  # Log with metadata\nwith span(request_id=\"12345\", user_id=\"alice\"):  # Log within a span\n    logger.info(M(\"User action\", action=\"update_profile\"))\n</code></pre> <p><code>M</code> and <code>JSONFormatter</code> work together to produce log records that include the specified metadata and span context, but can both be used independently if desired. Using <code>M</code> will produce a stringified message that includes the metadata in JSON, even without <code>JSONFormatter</code>.</p> <p>An alternative is <code>LogfmtFormatter</code>, which formats log records in logfmt format. It works just like <code>JSONFormatter</code>, but produces log records in logfmt instead of JSON.</p> Note <p>The keys <code>spanId</code> and <code>parentSpanId</code> are reserved for span tracking and should not be used in metadata passed to <code>M</code> or <code>span</code>. They are named to match OpenTelemetry conventions, though this module does not implement OpenTelemetry itself nor aims to be compatible with it.</p>"},{"location":"adjunct.slog/#adjunct.slog.span","title":"<code>span = _SpanStack()</code>  <code>module-attribute</code>","text":"<p>A context manager for logging spans.</p> <p>Functions:</p> Name Description <code>extend</code> <p>Add additional context to the current span. As this modifies the current span, using it within a span may lead to confusing logs; it is generally not recommended. It accepts the same key-value pairs as the context manager.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with slog.span(request_id=\"12345\", user_id=\"alice\"):\n...    logger.info(slog.M(\"User action\", action=\"update_profile\"))\n</code></pre>"},{"location":"adjunct.slog/#adjunct.slog.JSONFormatter","title":"<code>JSONFormatter</code>","text":"<p>               Bases: <code>_BaseFormatter</code></p> <p>A logging formatter that outputs JSON log records.</p>"},{"location":"adjunct.slog/#adjunct.slog.LogfmtFormatter","title":"<code>LogfmtFormatter</code>","text":"<p>               Bases: <code>_BaseFormatter</code></p> <p>A logging formatter that outputs log records in logfmt format.</p>"},{"location":"adjunct.slog/#adjunct.slog.M","title":"<code>M</code>","text":"<p>A message with some attached metaadata for structured logging.</p> <p>When stringified, this produces a JSON-like string that can be parsed by log processors.</p> <p>If used with JSONFormatter, it'll merge the metadata into the log record.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The main log message.</p> required <code>**metadata</code> <code>Scalar</code> <p>Additional key-value pairs to attach to the log record.</p> <code>{}</code>"},{"location":"adjunct.time/","title":"adjunct.time","text":"<p>Date/time utilities.</p>"},{"location":"adjunct.time/#adjunct.time.parse_dt","title":"<code>parse_dt(dt, tz=datetime.UTC)</code>","text":"<p>Parse an SQLite datetime, treating it as UTC by default.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>str</code> <p>an SQLite timestamp string</p> required <code>tz</code> <code>tzinfo | None</code> <p>the timezone to use, or <code>None</code> to treat it naively</p> <code>UTC</code> <p>Returns:</p> Type Description <code>datetime</code> <p>the parsed datetime.</p>"},{"location":"adjunct.time/#adjunct.time.to_iso_date","title":"<code>to_iso_date(dt, tz=datetime.UTC)</code>","text":"<p>Convert an SQLite timestamp string to ISO 8601 format.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>str</code> <p>an SQLite timestamp string</p> required <code>tz</code> <code>tzinfo</code> <p>a timezone object</p> <code>UTC</code> <p>Returns:</p> Type Description <code>str</code> <p>the same timestamp, but in ISO 8601 format.</p>"},{"location":"adjunct.totp/","title":"adjunct.totp","text":"<p>Adjunct has a TOTP implementation, providing a second factor of authentication.</p> <pre><code>from adjunct import totp\n\n# Instantiate a TOTP object with a reasonable set of defaults\nt = totp.TOTP()\n\n# Generate a token\nprint(t.generate())\n</code></pre> <p>To allow the object to be stored in a user's profile, you can use the <code>to_dict</code> method so you can serialise it as JSON or another format, and subsequently recreate the object using the <code>from_dict</code> class method.</p> <pre><code>import json\n\n# Dump it as JSON\nt1 = totp.TOTP()\nas_json = json.dumps(t1.to_dict())\n\n# Take some previously serialised JSON and recreate the object.\nt2 = totp.TOTP.from_dict(json.loads(as_json))\n</code></pre> <p>It can also be converted into an OTP key URI, which can be presented to the user so they can add it to their OTP generator.</p> <pre><code>print(t1.to_url(\"jane.doe@example.com\", issuer=\"Yoyodyne\"))\n</code></pre> <p>Finally, to check a code, pass it to <code>check</code> method to validate a code provided by the user.</p> <pre><code>while True:\n    otp = input(\"Enter your TOTP: \")\n    if t1.check(otp):\n        break\n    print(\"Invalid! Try again.\")\nprint(\"Valid\")\n</code></pre> <p>By default it uses the current window and the previous one. You can use the <code>window</code> named argument to change this from the default.</p>"},{"location":"adjunct.totp/#adjunct.totp.TOTP","title":"<code>TOTP</code>","text":"<p>An implementation of TOTP (RFC 6238).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>bytes | None</code> <p>A buffer of random bytes acting as a key. Will be generated if None.</p> <code>None</code> <code>alg</code> <code>str</code> <p>Hash algorithm to use for the OTP. Defaults to \"sha1\", but supports sha256 and sha512.</p> <code>'sha1'</code> <code>digits</code> <code>int</code> <p>Length of the OTP. Defaults to 6 digits.</p> <code>6</code> <code>period</code> <code>int</code> <p>Validity period in seconds of the OTP. Defaults to 30.</p> <code>30</code> <code>key_size</code> <code>int</code> <p>If no key is given, the length in bytes of the key go generate. Default to 16.</p> <code>16</code> <p>Raises:</p> Type Description <code>UnknownHashAlgorithmError</code> <p>If the hash algorithm given is not recognised.</p>"},{"location":"adjunct.totp/#adjunct.totp.TOTP.check","title":"<code>check(otp, *, window=2, now=None)</code>","text":"<p>Check a TOTP against the current expected TOTP and the previous one.</p> <p>Parameters:</p> Name Type Description Default <code>otp</code> <code>str</code> <p>OTP to check.</p> required <code>window</code> <code>int</code> <p>Number of windows back in time to use when checking checking the OTP.</p> <code>2</code> <code>now</code> <code>int | None</code> <p>A Unix timestamp. Defaults to the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the OTP matched, False otherwise.</p>"},{"location":"adjunct.totp/#adjunct.totp.TOTP.from_dict","title":"<code>from_dict(src)</code>  <code>classmethod</code>","text":"<p>Extract the state from a dictionary.</p>"},{"location":"adjunct.totp/#adjunct.totp.TOTP.generate","title":"<code>generate(now=None)</code>","text":"<p>Generate a TOTP.</p> <p>Parameters:</p> Name Type Description Default <code>now</code> <code>int | None</code> <p>A Unix timestamp. Defaults to the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The TOTP.</p>"},{"location":"adjunct.totp/#adjunct.totp.TOTP.to_dict","title":"<code>to_dict()</code>","text":"<p>Write the state to a dictionary for serialisation.</p>"},{"location":"adjunct.totp/#adjunct.totp.TOTP.to_url","title":"<code>to_url(account_name, issuer=None)</code>","text":"<p>Convert the object to a Google Authenticator key URI.</p> <p>Parameters:</p> Name Type Description Default <code>account_name</code> <code>str</code> <p>The user's account name.</p> required <code>issuer</code> <code>str | None</code> <p>The name of the issuer.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>An OTP key URI.</p>"},{"location":"adjunct.totp/#adjunct.totp.UnknownHashAlgorithmError","title":"<code>UnknownHashAlgorithmError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised if the named hash algorithm was not recognised.</p> <p>Parameters:</p> Name Type Description Default <code>alg</code> <code>str</code> <p>Hash algorithm name given</p> required"},{"location":"adjunct.xmlutils/","title":"adjunct.xmlutils","text":"<p>XML utilities.</p>"},{"location":"adjunct.xmlutils/#adjunct.xmlutils.XMLBuilder","title":"<code>XMLBuilder</code>","text":"<p>An XML document builder.</p> <p>It's purposely namespace ignorant: it's up to user to supply appropriate <code>xmlns</code> attributes as needed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xml = XMLBuilder()\n&gt;&gt;&gt; with xml.within('root', xmlns='tag:talideon.com,2013:test'):\n...     xml += 'Before'\n...     with xml.within('leaf'):\n...         xml += 'Within'\n...     xml += 'After'\n...     xml.tag('leaf', 'Another')\n&gt;&gt;&gt; print xml.as_string()\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;root xmlns=\"tag:talideon.com,2013:test\"&gt;Before&lt;leaf&gt;Within&lt;/leaf&gt;After&lt;leaf&gt;Another&lt;/leaf&gt;&lt;/root&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>out</code> <code>TextIO | None</code> <p>a file-like object to write the document to; if none is provided, a buffer is created.</p> <code>None</code> Note <p>If you provide your own, the <code>as_string()</code> method will return an empty string as no other sensible value can be returned.</p>"},{"location":"adjunct.xmlutils/#adjunct.xmlutils.XMLBuilder.append","title":"<code>append(other)</code>","text":"<p>Append the string to this document.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>str</code> <p>a string to write to the document</p> required"},{"location":"adjunct.xmlutils/#adjunct.xmlutils.XMLBuilder.as_string","title":"<code>as_string()</code>","text":"<p>If using the built-in buffer, get its current contents.</p>"},{"location":"adjunct.xmlutils/#adjunct.xmlutils.XMLBuilder.close","title":"<code>close()</code>","text":"<p>If using the built-in buffer, clean it up.</p>"},{"location":"adjunct.xmlutils/#adjunct.xmlutils.XMLBuilder.tag","title":"<code>tag(tag, *values, **attrs)</code>","text":"<p>Generates a simple element.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>the tag name</p> required <code>values</code> <code>str</code> <p>any character data to write between the start and end tag</p> <code>()</code> <code>attrs</code> <code>str</code> <p>any attributes to add to the tag</p> <code>{}</code>"},{"location":"adjunct.xmlutils/#adjunct.xmlutils.XMLBuilder.within","title":"<code>within(tag, **attrs)</code>","text":"<p>Generates an element containing nested elements.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>the tag name</p> required <code>attrs</code> <code>str</code> <p>any attributes to add to the tag</p> <code>{}</code>"}]}