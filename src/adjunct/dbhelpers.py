"""Helpers for interacting with databases."""

import typing as t

__all__ = ["execute", "query", "query_row", "query_value"]


Scalar = str | int | float | None
Row = t.Sequence[Scalar] | dict[str, Scalar]


class _Cursor(t.Protocol):
    """A DBAPI cursor (subset)."""

    lastrowid: int

    arraysize: int

    def callproc(self, procname: str, args: t.Sequence[Scalar]):
        """Call a stored procedure with the given name."""
        ...

    def close(self) -> None:
        """Close the cursor immediately."""
        ...

    def execute(self, operation: str, args: t.Sequence[Scalar]):
        """Prepare and execute a database operation/query."""
        ...

    def executemany(self, operation: str, seq_of_parameters: t.Iterable[t.Iterable[Scalar]]):
        """Prepare an operation and execute it against all the parameter sequences."""
        ...

    def fetchone(self) -> Row:
        """Fetch the next row in the result set."""
        ...

    def fetchall(self) -> t.Iterable[Row]:
        """Fetch all remaining rows in the query result."""
        ...

    def nextset(self) -> None:
        """Skip to the next available result set."""
        ...


class _Connection(t.Protocol):
    """PEP 249: Database API Connection"""

    def close(self) -> None:
        """Close the connection."""
        ...

    def commit(self) -> None:
        """Commit the pending transaction to the database."""
        ...

    def rollback(self) -> None:
        """Rollback the pending transaction."""
        ...

    def cursor(self) -> _Cursor:
        """Return a cursor using the connection."""
        ...


def execute(
    con: _Connection,
    sql: str,
    args: t.Sequence[Scalar] = (),
) -> int | None:
    """Execute an SQL statement.

    Args:
        con: connection object
        sql: the statement to execute
        args: arguments to interpolate into the statement

    Returns:
        The value of `lastrowid`, usually an autogenerated primary key.
    """
    cur = con.cursor()
    cur.arraysize = 50
    try:
        cur.execute(sql, args)
        result = cur.lastrowid
        con.commit()
        return result
    finally:
        cur.close()


def query(
    con: _Connection,
    sql: str,
    args: t.Sequence[Scalar] = (),
) -> t.Iterator[Row]:
    """Run an SQL query.

    Args:
        con: connection object
        sql: the statement to execute
        args: arguments to interpolate into the statement

    Yields:
        The rows of the result.
    """
    cur = con.cursor()
    try:
        cur.execute(sql, args)
        yield from iter(cur.fetchone, None)
    finally:
        cur.close()


def query_row(
    con: _Connection,
    sql: str,
    args: t.Sequence[Scalar] = (),
    *,
    default: Row | None = None,
) -> Row | None:
    """Run an SQL query expected to return a single row.

    Args:
        con: connection object
        sql: the statement to execute
        args: arguments to interpolate into the statement
        default: value to return if no rows are returned by the query

    Returns:
        The matched row.
    """

    cur = con.cursor()
    try:
        cur.execute(sql, args)
        for row in iter(cur.fetchone, None):
            return row
    finally:
        cur.close()
    return default


def query_value(
    con: _Connection,
    sql: str,
    args: t.Sequence[Scalar] = (),
    *,
    default: Scalar = None,
) -> Scalar:
    """Run an SQL query expected to return a single value.

    Args:
        con: connection object
        sql: the statement to execute
        args: arguments to interpolate into the statement
        default: value to return if no rows are returned by the query

    Returns:
        The first field of the matched row.
    """
    cur = con.cursor()
    try:
        cur.execute(sql, args)
        for row in iter(cur.fetchone, None):
            if isinstance(row, t.Sequence):
                return row[0]
            return row[next(iter(row.keys()))]
    finally:
        cur.close()
    return default
